<?php
/**
 * ModApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Kleister
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Kleister OpenAPI
 *
 * API definition for Kleister, manage mod packs for Minecraft
 *
 * The version of the OpenAPI document: 1.0.0-alpha1
 * Contact: kleister@webhippie.de
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Kleister\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Kleister\ApiException;
use Kleister\Configuration;
use Kleister\FormDataProcessor;
use Kleister\HeaderSelector;
use Kleister\ObjectSerializer;

/**
 * ModApi Class Doc Comment
 *
 * @category Class
 * @package  Kleister
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ModApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'attachModToGroup' => [
            'application/json',
        ],
        'attachModToUser' => [
            'application/json',
        ],
        'attachVersionToBuild' => [
            'application/json',
        ],
        'createMod' => [
            'application/json',
        ],
        'createModAvatar' => [
            'multipart/form-data',
        ],
        'createPackAvatar' => [
            'multipart/form-data',
        ],
        'createVersion' => [
            'application/json',
        ],
        'deleteMod' => [
            'application/json',
        ],
        'deleteModAvatar' => [
            'application/json',
        ],
        'deleteModFromGroup' => [
            'application/json',
        ],
        'deleteModFromUser' => [
            'application/json',
        ],
        'deletePackAvatar' => [
            'application/json',
        ],
        'deleteVersion' => [
            'application/json',
        ],
        'deleteVersionFromBuild' => [
            'application/json',
        ],
        'listModGroups' => [
            'application/json',
        ],
        'listModUsers' => [
            'application/json',
        ],
        'listMods' => [
            'application/json',
        ],
        'listVersionBuilds' => [
            'application/json',
        ],
        'listVersions' => [
            'application/json',
        ],
        'permitModGroup' => [
            'application/json',
        ],
        'permitModUser' => [
            'application/json',
        ],
        'showMod' => [
            'application/json',
        ],
        'showVersion' => [
            'application/json',
        ],
        'updateMod' => [
            'application/json',
        ],
        'updateVersion' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation attachModToGroup
     *
     * Attach a group to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function attachModToGroup($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['attachModToGroup'][0])
    {
        list($response) = $this->attachModToGroupWithHttpInfo($modId, $permitPackGroupRequest, $contentType);
        return $response;
    }

    /**
     * Operation attachModToGroupWithHttpInfo
     *
     * Attach a group to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function attachModToGroupWithHttpInfo($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['attachModToGroup'][0])
    {
        $request = $this->attachModToGroupRequest($modId, $permitPackGroupRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation attachModToGroupAsync
     *
     * Attach a group to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachModToGroupAsync($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['attachModToGroup'][0])
    {
        return $this->attachModToGroupAsyncWithHttpInfo($modId, $permitPackGroupRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attachModToGroupAsyncWithHttpInfo
     *
     * Attach a group to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachModToGroupAsyncWithHttpInfo($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['attachModToGroup'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->attachModToGroupRequest($modId, $permitPackGroupRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attachModToGroup'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function attachModToGroupRequest($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['attachModToGroup'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling attachModToGroup'
            );
        }

        // verify the required parameter 'permitPackGroupRequest' is set
        if ($permitPackGroupRequest === null || (is_array($permitPackGroupRequest) && count($permitPackGroupRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permitPackGroupRequest when calling attachModToGroup'
            );
        }


        $resourcePath = '/mods/{mod_id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($permitPackGroupRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($permitPackGroupRequest));
            } else {
                $httpBody = $permitPackGroupRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attachModToUser
     *
     * Attach a user to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function attachModToUser($modId, $permitPackUserRequest, string $contentType = self::contentTypes['attachModToUser'][0])
    {
        list($response) = $this->attachModToUserWithHttpInfo($modId, $permitPackUserRequest, $contentType);
        return $response;
    }

    /**
     * Operation attachModToUserWithHttpInfo
     *
     * Attach a user to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function attachModToUserWithHttpInfo($modId, $permitPackUserRequest, string $contentType = self::contentTypes['attachModToUser'][0])
    {
        $request = $this->attachModToUserRequest($modId, $permitPackUserRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation attachModToUserAsync
     *
     * Attach a user to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachModToUserAsync($modId, $permitPackUserRequest, string $contentType = self::contentTypes['attachModToUser'][0])
    {
        return $this->attachModToUserAsyncWithHttpInfo($modId, $permitPackUserRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attachModToUserAsyncWithHttpInfo
     *
     * Attach a user to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachModToUserAsyncWithHttpInfo($modId, $permitPackUserRequest, string $contentType = self::contentTypes['attachModToUser'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->attachModToUserRequest($modId, $permitPackUserRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attachModToUser'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachModToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function attachModToUserRequest($modId, $permitPackUserRequest, string $contentType = self::contentTypes['attachModToUser'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling attachModToUser'
            );
        }

        // verify the required parameter 'permitPackUserRequest' is set
        if ($permitPackUserRequest === null || (is_array($permitPackUserRequest) && count($permitPackUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permitPackUserRequest when calling attachModToUser'
            );
        }


        $resourcePath = '/mods/{mod_id}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($permitPackUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($permitPackUserRequest));
            } else {
                $httpBody = $permitPackUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attachVersionToBuild
     *
     * Attach a build to a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachVersionToBuild'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function attachVersionToBuild($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['attachVersionToBuild'][0])
    {
        list($response) = $this->attachVersionToBuildWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);
        return $response;
    }

    /**
     * Operation attachVersionToBuildWithHttpInfo
     *
     * Attach a build to a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachVersionToBuild'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function attachVersionToBuildWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['attachVersionToBuild'][0])
    {
        $request = $this->attachVersionToBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation attachVersionToBuildAsync
     *
     * Attach a build to a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachVersionToBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachVersionToBuildAsync($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['attachVersionToBuild'][0])
    {
        return $this->attachVersionToBuildAsyncWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attachVersionToBuildAsyncWithHttpInfo
     *
     * Attach a build to a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachVersionToBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attachVersionToBuildAsyncWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['attachVersionToBuild'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->attachVersionToBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attachVersionToBuild'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['attachVersionToBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function attachVersionToBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['attachVersionToBuild'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling attachVersionToBuild'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling attachVersionToBuild'
            );
        }

        // verify the required parameter 'attachMinecraftToBuildRequest' is set
        if ($attachMinecraftToBuildRequest === null || (is_array($attachMinecraftToBuildRequest) && count($attachMinecraftToBuildRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachMinecraftToBuildRequest when calling attachVersionToBuild'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions/{version_id}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attachMinecraftToBuildRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attachMinecraftToBuildRequest));
            } else {
                $httpBody = $attachMinecraftToBuildRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMod
     *
     * Create a new mod
     *
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function createMod($createModRequest, string $contentType = self::contentTypes['createMod'][0])
    {
        list($response) = $this->createModWithHttpInfo($createModRequest, $contentType);
        return $response;
    }

    /**
     * Operation createModWithHttpInfo
     *
     * Create a new mod
     *
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModWithHttpInfo($createModRequest, string $contentType = self::contentTypes['createMod'][0])
    {
        $request = $this->createModRequest($createModRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Mod',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Mod',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Mod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createModAsync
     *
     * Create a new mod
     *
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModAsync($createModRequest, string $contentType = self::contentTypes['createMod'][0])
    {
        return $this->createModAsyncWithHttpInfo($createModRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModAsyncWithHttpInfo
     *
     * Create a new mod
     *
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModAsyncWithHttpInfo($createModRequest, string $contentType = self::contentTypes['createMod'][0])
    {
        $returnType = '\Kleister\Model\Mod';
        $request = $this->createModRequest($createModRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMod'
     *
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModRequest($createModRequest, string $contentType = self::contentTypes['createMod'][0])
    {

        // verify the required parameter 'createModRequest' is set
        if ($createModRequest === null || (is_array($createModRequest) && count($createModRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createModRequest when calling createMod'
            );
        }


        $resourcePath = '/mods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createModRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createModRequest));
            } else {
                $httpBody = $createModRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createModAvatar
     *
     * Upload an avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \SplFileObject|null $file file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ModAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function createModAvatar($modId, $file = null, string $contentType = self::contentTypes['createModAvatar'][0])
    {
        list($response) = $this->createModAvatarWithHttpInfo($modId, $file, $contentType);
        return $response;
    }

    /**
     * Operation createModAvatarWithHttpInfo
     *
     * Upload an avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ModAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModAvatarWithHttpInfo($modId, $file = null, string $contentType = self::contentTypes['createModAvatar'][0])
    {
        $request = $this->createModAvatarRequest($modId, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ModAvatar',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ModAvatar',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ModAvatar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createModAvatarAsync
     *
     * Upload an avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModAvatarAsync($modId, $file = null, string $contentType = self::contentTypes['createModAvatar'][0])
    {
        return $this->createModAvatarAsyncWithHttpInfo($modId, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModAvatarAsyncWithHttpInfo
     *
     * Upload an avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModAvatarAsyncWithHttpInfo($modId, $file = null, string $contentType = self::contentTypes['createModAvatar'][0])
    {
        $returnType = '\Kleister\Model\ModAvatar';
        $request = $this->createModAvatarRequest($modId, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModAvatar'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModAvatarRequest($modId, $file = null, string $contentType = self::contentTypes['createModAvatar'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling createModAvatar'
            );
        }



        $resourcePath = '/mods/{mod_id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPackAvatar
     *
     * Upload an avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  \SplFileObject|null $file file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPackAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\PackAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function createPackAvatar($packId, $file = null, string $contentType = self::contentTypes['createPackAvatar'][0])
    {
        list($response) = $this->createPackAvatarWithHttpInfo($packId, $file, $contentType);
        return $response;
    }

    /**
     * Operation createPackAvatarWithHttpInfo
     *
     * Upload an avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPackAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\PackAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPackAvatarWithHttpInfo($packId, $file = null, string $contentType = self::contentTypes['createPackAvatar'][0])
    {
        $request = $this->createPackAvatarRequest($packId, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\PackAvatar',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\PackAvatar',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\PackAvatar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createPackAvatarAsync
     *
     * Upload an avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPackAvatarAsync($packId, $file = null, string $contentType = self::contentTypes['createPackAvatar'][0])
    {
        return $this->createPackAvatarAsyncWithHttpInfo($packId, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPackAvatarAsyncWithHttpInfo
     *
     * Upload an avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPackAvatarAsyncWithHttpInfo($packId, $file = null, string $contentType = self::contentTypes['createPackAvatar'][0])
    {
        $returnType = '\Kleister\Model\PackAvatar';
        $request = $this->createPackAvatarRequest($packId, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPackAvatar'
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPackAvatarRequest($packId, $file = null, string $contentType = self::contentTypes['createPackAvatar'][0])
    {

        // verify the required parameter 'packId' is set
        if ($packId === null || (is_array($packId) && count($packId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packId when calling createPackAvatar'
            );
        }



        $resourcePath = '/packs/{pack_id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($packId !== null) {
            $resourcePath = str_replace(
                '{' . 'pack_id' . '}',
                ObjectSerializer::toPathValue($packId),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVersion
     *
     * Create a new version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function createVersion($modId, $createVersionRequest, string $contentType = self::contentTypes['createVersion'][0])
    {
        list($response) = $this->createVersionWithHttpInfo($modId, $createVersionRequest, $contentType);
        return $response;
    }

    /**
     * Operation createVersionWithHttpInfo
     *
     * Create a new version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVersionWithHttpInfo($modId, $createVersionRequest, string $contentType = self::contentTypes['createVersion'][0])
    {
        $request = $this->createVersionRequest($modId, $createVersionRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Version',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Version',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Version',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createVersionAsync
     *
     * Create a new version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVersionAsync($modId, $createVersionRequest, string $contentType = self::contentTypes['createVersion'][0])
    {
        return $this->createVersionAsyncWithHttpInfo($modId, $createVersionRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVersionAsyncWithHttpInfo
     *
     * Create a new version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVersionAsyncWithHttpInfo($modId, $createVersionRequest, string $contentType = self::contentTypes['createVersion'][0])
    {
        $returnType = '\Kleister\Model\Version';
        $request = $this->createVersionRequest($modId, $createVersionRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVersion'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVersionRequest($modId, $createVersionRequest, string $contentType = self::contentTypes['createVersion'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling createVersion'
            );
        }

        // verify the required parameter 'createVersionRequest' is set
        if ($createVersionRequest === null || (is_array($createVersionRequest) && count($createVersionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createVersionRequest when calling createVersion'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createVersionRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createVersionRequest));
            } else {
                $httpBody = $createVersionRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMod
     *
     * Delete a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteMod($modId, string $contentType = self::contentTypes['deleteMod'][0])
    {
        list($response) = $this->deleteModWithHttpInfo($modId, $contentType);
        return $response;
    }

    /**
     * Operation deleteModWithHttpInfo
     *
     * Delete a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModWithHttpInfo($modId, string $contentType = self::contentTypes['deleteMod'][0])
    {
        $request = $this->deleteModRequest($modId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteModAsync
     *
     * Delete a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModAsync($modId, string $contentType = self::contentTypes['deleteMod'][0])
    {
        return $this->deleteModAsyncWithHttpInfo($modId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModAsyncWithHttpInfo
     *
     * Delete a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModAsyncWithHttpInfo($modId, string $contentType = self::contentTypes['deleteMod'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->deleteModRequest($modId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMod'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModRequest($modId, string $contentType = self::contentTypes['deleteMod'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteMod'
            );
        }


        $resourcePath = '/mods/{mod_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModAvatar
     *
     * Delete the avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ModAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteModAvatar($modId, string $contentType = self::contentTypes['deleteModAvatar'][0])
    {
        list($response) = $this->deleteModAvatarWithHttpInfo($modId, $contentType);
        return $response;
    }

    /**
     * Operation deleteModAvatarWithHttpInfo
     *
     * Delete the avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ModAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModAvatarWithHttpInfo($modId, string $contentType = self::contentTypes['deleteModAvatar'][0])
    {
        $request = $this->deleteModAvatarRequest($modId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ModAvatar',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ModAvatar',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ModAvatar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteModAvatarAsync
     *
     * Delete the avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModAvatarAsync($modId, string $contentType = self::contentTypes['deleteModAvatar'][0])
    {
        return $this->deleteModAvatarAsyncWithHttpInfo($modId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModAvatarAsyncWithHttpInfo
     *
     * Delete the avatar for the defined mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModAvatarAsyncWithHttpInfo($modId, string $contentType = self::contentTypes['deleteModAvatar'][0])
    {
        $returnType = '\Kleister\Model\ModAvatar';
        $request = $this->deleteModAvatarRequest($modId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModAvatar'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModAvatarRequest($modId, string $contentType = self::contentTypes['deleteModAvatar'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteModAvatar'
            );
        }


        $resourcePath = '/mods/{mod_id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModFromGroup
     *
     * Unlink a group from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromGroupRequest $deletePackFromGroupRequest The mod group data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteModFromGroup($modId, $deletePackFromGroupRequest, string $contentType = self::contentTypes['deleteModFromGroup'][0])
    {
        list($response) = $this->deleteModFromGroupWithHttpInfo($modId, $deletePackFromGroupRequest, $contentType);
        return $response;
    }

    /**
     * Operation deleteModFromGroupWithHttpInfo
     *
     * Unlink a group from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromGroupRequest $deletePackFromGroupRequest The mod group data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModFromGroupWithHttpInfo($modId, $deletePackFromGroupRequest, string $contentType = self::contentTypes['deleteModFromGroup'][0])
    {
        $request = $this->deleteModFromGroupRequest($modId, $deletePackFromGroupRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteModFromGroupAsync
     *
     * Unlink a group from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromGroupRequest $deletePackFromGroupRequest The mod group data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModFromGroupAsync($modId, $deletePackFromGroupRequest, string $contentType = self::contentTypes['deleteModFromGroup'][0])
    {
        return $this->deleteModFromGroupAsyncWithHttpInfo($modId, $deletePackFromGroupRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModFromGroupAsyncWithHttpInfo
     *
     * Unlink a group from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromGroupRequest $deletePackFromGroupRequest The mod group data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModFromGroupAsyncWithHttpInfo($modId, $deletePackFromGroupRequest, string $contentType = self::contentTypes['deleteModFromGroup'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->deleteModFromGroupRequest($modId, $deletePackFromGroupRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModFromGroup'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromGroupRequest $deletePackFromGroupRequest The mod group data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModFromGroupRequest($modId, $deletePackFromGroupRequest, string $contentType = self::contentTypes['deleteModFromGroup'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteModFromGroup'
            );
        }

        // verify the required parameter 'deletePackFromGroupRequest' is set
        if ($deletePackFromGroupRequest === null || (is_array($deletePackFromGroupRequest) && count($deletePackFromGroupRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deletePackFromGroupRequest when calling deleteModFromGroup'
            );
        }


        $resourcePath = '/mods/{mod_id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deletePackFromGroupRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deletePackFromGroupRequest));
            } else {
                $httpBody = $deletePackFromGroupRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModFromUser
     *
     * Unlink a user from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromUserRequest $deletePackFromUserRequest The mod user data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteModFromUser($modId, $deletePackFromUserRequest, string $contentType = self::contentTypes['deleteModFromUser'][0])
    {
        list($response) = $this->deleteModFromUserWithHttpInfo($modId, $deletePackFromUserRequest, $contentType);
        return $response;
    }

    /**
     * Operation deleteModFromUserWithHttpInfo
     *
     * Unlink a user from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromUserRequest $deletePackFromUserRequest The mod user data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModFromUserWithHttpInfo($modId, $deletePackFromUserRequest, string $contentType = self::contentTypes['deleteModFromUser'][0])
    {
        $request = $this->deleteModFromUserRequest($modId, $deletePackFromUserRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteModFromUserAsync
     *
     * Unlink a user from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromUserRequest $deletePackFromUserRequest The mod user data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModFromUserAsync($modId, $deletePackFromUserRequest, string $contentType = self::contentTypes['deleteModFromUser'][0])
    {
        return $this->deleteModFromUserAsyncWithHttpInfo($modId, $deletePackFromUserRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModFromUserAsyncWithHttpInfo
     *
     * Unlink a user from mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromUserRequest $deletePackFromUserRequest The mod user data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModFromUserAsyncWithHttpInfo($modId, $deletePackFromUserRequest, string $contentType = self::contentTypes['deleteModFromUser'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->deleteModFromUserRequest($modId, $deletePackFromUserRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModFromUser'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\DeletePackFromUserRequest $deletePackFromUserRequest The mod user data to unlink (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteModFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteModFromUserRequest($modId, $deletePackFromUserRequest, string $contentType = self::contentTypes['deleteModFromUser'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteModFromUser'
            );
        }

        // verify the required parameter 'deletePackFromUserRequest' is set
        if ($deletePackFromUserRequest === null || (is_array($deletePackFromUserRequest) && count($deletePackFromUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deletePackFromUserRequest when calling deleteModFromUser'
            );
        }


        $resourcePath = '/mods/{mod_id}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deletePackFromUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deletePackFromUserRequest));
            } else {
                $httpBody = $deletePackFromUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePackAvatar
     *
     * Delete the avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePackAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\PackAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deletePackAvatar($packId, string $contentType = self::contentTypes['deletePackAvatar'][0])
    {
        list($response) = $this->deletePackAvatarWithHttpInfo($packId, $contentType);
        return $response;
    }

    /**
     * Operation deletePackAvatarWithHttpInfo
     *
     * Delete the avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePackAvatar'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\PackAvatar|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePackAvatarWithHttpInfo($packId, string $contentType = self::contentTypes['deletePackAvatar'][0])
    {
        $request = $this->deletePackAvatarRequest($packId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\PackAvatar',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\PackAvatar',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\PackAvatar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deletePackAvatarAsync
     *
     * Delete the avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePackAvatarAsync($packId, string $contentType = self::contentTypes['deletePackAvatar'][0])
    {
        return $this->deletePackAvatarAsyncWithHttpInfo($packId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePackAvatarAsyncWithHttpInfo
     *
     * Delete the avatar for the defined pack
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePackAvatarAsyncWithHttpInfo($packId, string $contentType = self::contentTypes['deletePackAvatar'][0])
    {
        $returnType = '\Kleister\Model\PackAvatar';
        $request = $this->deletePackAvatarRequest($packId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePackAvatar'
     *
     * @param  string $packId A pack identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePackAvatar'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePackAvatarRequest($packId, string $contentType = self::contentTypes['deletePackAvatar'][0])
    {

        // verify the required parameter 'packId' is set
        if ($packId === null || (is_array($packId) && count($packId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packId when calling deletePackAvatar'
            );
        }


        $resourcePath = '/packs/{pack_id}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($packId !== null) {
            $resourcePath = str_replace(
                '{' . 'pack_id' . '}',
                ObjectSerializer::toPathValue($packId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVersion
     *
     * Delete a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteVersion($modId, $versionId, string $contentType = self::contentTypes['deleteVersion'][0])
    {
        list($response) = $this->deleteVersionWithHttpInfo($modId, $versionId, $contentType);
        return $response;
    }

    /**
     * Operation deleteVersionWithHttpInfo
     *
     * Delete a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVersionWithHttpInfo($modId, $versionId, string $contentType = self::contentTypes['deleteVersion'][0])
    {
        $request = $this->deleteVersionRequest($modId, $versionId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteVersionAsync
     *
     * Delete a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionAsync($modId, $versionId, string $contentType = self::contentTypes['deleteVersion'][0])
    {
        return $this->deleteVersionAsyncWithHttpInfo($modId, $versionId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVersionAsyncWithHttpInfo
     *
     * Delete a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionAsyncWithHttpInfo($modId, $versionId, string $contentType = self::contentTypes['deleteVersion'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->deleteVersionRequest($modId, $versionId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVersion'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVersionRequest($modId, $versionId, string $contentType = self::contentTypes['deleteVersion'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteVersion'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling deleteVersion'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions/{version_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVersionFromBuild
     *
     * Unlink a build from a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersionFromBuild'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function deleteVersionFromBuild($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['deleteVersionFromBuild'][0])
    {
        list($response) = $this->deleteVersionFromBuildWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);
        return $response;
    }

    /**
     * Operation deleteVersionFromBuildWithHttpInfo
     *
     * Unlink a build from a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersionFromBuild'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVersionFromBuildWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['deleteVersionFromBuild'][0])
    {
        $request = $this->deleteVersionFromBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteVersionFromBuildAsync
     *
     * Unlink a build from a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersionFromBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionFromBuildAsync($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['deleteVersionFromBuild'][0])
    {
        return $this->deleteVersionFromBuildAsyncWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVersionFromBuildAsyncWithHttpInfo
     *
     * Unlink a build from a version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersionFromBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVersionFromBuildAsyncWithHttpInfo($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['deleteVersionFromBuild'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->deleteVersionFromBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVersionFromBuild'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\AttachMinecraftToBuildRequest $attachMinecraftToBuildRequest The version build data to create or delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVersionFromBuild'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVersionFromBuildRequest($modId, $versionId, $attachMinecraftToBuildRequest, string $contentType = self::contentTypes['deleteVersionFromBuild'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling deleteVersionFromBuild'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling deleteVersionFromBuild'
            );
        }

        // verify the required parameter 'attachMinecraftToBuildRequest' is set
        if ($attachMinecraftToBuildRequest === null || (is_array($attachMinecraftToBuildRequest) && count($attachMinecraftToBuildRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachMinecraftToBuildRequest when calling deleteVersionFromBuild'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions/{version_id}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attachMinecraftToBuildRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attachMinecraftToBuildRequest));
            } else {
                $httpBody = $attachMinecraftToBuildRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listModGroups
     *
     * Fetch all groups attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModGroups'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ListModGroups200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function listModGroups($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModGroups'][0])
    {
        list($response) = $this->listModGroupsWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listModGroupsWithHttpInfo
     *
     * Fetch all groups attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModGroups'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ListModGroups200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function listModGroupsWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModGroups'][0])
    {
        $request = $this->listModGroupsRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ListModGroups200Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ListModGroups200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ListModGroups200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listModGroupsAsync
     *
     * Fetch all groups attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModGroupsAsync($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModGroups'][0])
    {
        return $this->listModGroupsAsyncWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModGroupsAsyncWithHttpInfo
     *
     * Fetch all groups attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModGroupsAsyncWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModGroups'][0])
    {
        $returnType = '\Kleister\Model\ListModGroups200Response';
        $request = $this->listModGroupsRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listModGroups'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModGroupsRequest($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModGroups'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling listModGroups'
            );
        }







        $resourcePath = '/mods/{mod_id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listModUsers
     *
     * Fetch all users attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModUsers'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ListModUsers200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function listModUsers($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModUsers'][0])
    {
        list($response) = $this->listModUsersWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listModUsersWithHttpInfo
     *
     * Fetch all users attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModUsers'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ListModUsers200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function listModUsersWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModUsers'][0])
    {
        $request = $this->listModUsersRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ListModUsers200Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ListModUsers200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ListModUsers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listModUsersAsync
     *
     * Fetch all users attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModUsersAsync($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModUsers'][0])
    {
        return $this->listModUsersAsyncWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModUsersAsyncWithHttpInfo
     *
     * Fetch all users attached to mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModUsersAsyncWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModUsers'][0])
    {
        $returnType = '\Kleister\Model\ListModUsers200Response';
        $request = $this->listModUsersRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listModUsers'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModUsersRequest($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listModUsers'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling listModUsers'
            );
        }







        $resourcePath = '/mods/{mod_id}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMods
     *
     * Fetch all available mods
     *
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMods'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ListMods200Response|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function listMods($search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listMods'][0])
    {
        list($response) = $this->listModsWithHttpInfo($search, $sort, $order, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listModsWithHttpInfo
     *
     * Fetch all available mods
     *
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMods'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ListMods200Response|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function listModsWithHttpInfo($search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listMods'][0])
    {
        $request = $this->listModsRequest($search, $sort, $order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ListMods200Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ListMods200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ListMods200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listModsAsync
     *
     * Fetch all available mods
     *
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModsAsync($search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listMods'][0])
    {
        return $this->listModsAsyncWithHttpInfo($search, $sort, $order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModsAsyncWithHttpInfo
     *
     * Fetch all available mods
     *
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModsAsyncWithHttpInfo($search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listMods'][0])
    {
        $returnType = '\Kleister\Model\ListMods200Response';
        $request = $this->listModsRequest($search, $sort, $order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMods'
     *
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModsRequest($search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listMods'][0])
    {







        $resourcePath = '/mods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVersionBuilds
     *
     * Fetch all builds attached to version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersionBuilds'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ListVersionBuilds200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function listVersionBuilds($modId, $versionId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersionBuilds'][0])
    {
        list($response) = $this->listVersionBuildsWithHttpInfo($modId, $versionId, $search, $sort, $order, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listVersionBuildsWithHttpInfo
     *
     * Fetch all builds attached to version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersionBuilds'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ListVersionBuilds200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVersionBuildsWithHttpInfo($modId, $versionId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersionBuilds'][0])
    {
        $request = $this->listVersionBuildsRequest($modId, $versionId, $search, $sort, $order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ListVersionBuilds200Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ListVersionBuilds200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ListVersionBuilds200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listVersionBuildsAsync
     *
     * Fetch all builds attached to version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersionBuilds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVersionBuildsAsync($modId, $versionId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersionBuilds'][0])
    {
        return $this->listVersionBuildsAsyncWithHttpInfo($modId, $versionId, $search, $sort, $order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVersionBuildsAsyncWithHttpInfo
     *
     * Fetch all builds attached to version
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersionBuilds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVersionBuildsAsyncWithHttpInfo($modId, $versionId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersionBuilds'][0])
    {
        $returnType = '\Kleister\Model\ListVersionBuilds200Response';
        $request = $this->listVersionBuildsRequest($modId, $versionId, $search, $sort, $order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVersionBuilds'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersionBuilds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listVersionBuildsRequest($modId, $versionId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersionBuilds'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling listVersionBuilds'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling listVersionBuilds'
            );
        }







        $resourcePath = '/mods/{mod_id}/versions/{version_id}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVersions
     *
     * Fetch all available versions for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersions'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\ListVersions200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function listVersions($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersions'][0])
    {
        list($response) = $this->listVersionsWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listVersionsWithHttpInfo
     *
     * Fetch all available versions for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersions'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\ListVersions200Response|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVersionsWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersions'][0])
    {
        $request = $this->listVersionsRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\ListVersions200Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\ListVersions200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\ListVersions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listVersionsAsync
     *
     * Fetch all available versions for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVersionsAsync($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersions'][0])
    {
        return $this->listVersionsAsyncWithHttpInfo($modId, $search, $sort, $order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVersionsAsyncWithHttpInfo
     *
     * Fetch all available versions for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVersionsAsyncWithHttpInfo($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersions'][0])
    {
        $returnType = '\Kleister\Model\ListVersions200Response';
        $request = $this->listVersionsRequest($modId, $search, $sort, $order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVersions'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string|null $search Search query (optional)
     * @param  string|null $sort Sorting column (optional)
     * @param  string|null $order Sorting order (optional, default to 'asc')
     * @param  int|null $limit Paging limit (optional, default to 100)
     * @param  int|null $offset Paging offset (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listVersionsRequest($modId, $search = null, $sort = null, $order = 'asc', $limit = 100, $offset = 0, string $contentType = self::contentTypes['listVersions'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling listVersions'
            );
        }







        $resourcePath = '/mods/{mod_id}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation permitModGroup
     *
     * Update group perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function permitModGroup($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['permitModGroup'][0])
    {
        list($response) = $this->permitModGroupWithHttpInfo($modId, $permitPackGroupRequest, $contentType);
        return $response;
    }

    /**
     * Operation permitModGroupWithHttpInfo
     *
     * Update group perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModGroup'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function permitModGroupWithHttpInfo($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['permitModGroup'][0])
    {
        $request = $this->permitModGroupRequest($modId, $permitPackGroupRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation permitModGroupAsync
     *
     * Update group perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function permitModGroupAsync($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['permitModGroup'][0])
    {
        return $this->permitModGroupAsyncWithHttpInfo($modId, $permitPackGroupRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation permitModGroupAsyncWithHttpInfo
     *
     * Update group perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function permitModGroupAsyncWithHttpInfo($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['permitModGroup'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->permitModGroupRequest($modId, $permitPackGroupRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'permitModGroup'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackGroupRequest $permitPackGroupRequest The mod group data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function permitModGroupRequest($modId, $permitPackGroupRequest, string $contentType = self::contentTypes['permitModGroup'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling permitModGroup'
            );
        }

        // verify the required parameter 'permitPackGroupRequest' is set
        if ($permitPackGroupRequest === null || (is_array($permitPackGroupRequest) && count($permitPackGroupRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permitPackGroupRequest when calling permitModGroup'
            );
        }


        $resourcePath = '/mods/{mod_id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($permitPackGroupRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($permitPackGroupRequest));
            } else {
                $httpBody = $permitPackGroupRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation permitModUser
     *
     * Update user perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function permitModUser($modId, $permitPackUserRequest, string $contentType = self::contentTypes['permitModUser'][0])
    {
        list($response) = $this->permitModUserWithHttpInfo($modId, $permitPackUserRequest, $contentType);
        return $response;
    }

    /**
     * Operation permitModUserWithHttpInfo
     *
     * Update user perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModUser'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function permitModUserWithHttpInfo($modId, $permitPackUserRequest, string $contentType = self::contentTypes['permitModUser'][0])
    {
        $request = $this->permitModUserRequest($modId, $permitPackUserRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Notification',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation permitModUserAsync
     *
     * Update user perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function permitModUserAsync($modId, $permitPackUserRequest, string $contentType = self::contentTypes['permitModUser'][0])
    {
        return $this->permitModUserAsyncWithHttpInfo($modId, $permitPackUserRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation permitModUserAsyncWithHttpInfo
     *
     * Update user perms for mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function permitModUserAsyncWithHttpInfo($modId, $permitPackUserRequest, string $contentType = self::contentTypes['permitModUser'][0])
    {
        $returnType = '\Kleister\Model\Notification';
        $request = $this->permitModUserRequest($modId, $permitPackUserRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'permitModUser'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\PermitPackUserRequest $permitPackUserRequest The mod user data to permit (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['permitModUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function permitModUserRequest($modId, $permitPackUserRequest, string $contentType = self::contentTypes['permitModUser'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling permitModUser'
            );
        }

        // verify the required parameter 'permitPackUserRequest' is set
        if ($permitPackUserRequest === null || (is_array($permitPackUserRequest) && count($permitPackUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permitPackUserRequest when calling permitModUser'
            );
        }


        $resourcePath = '/mods/{mod_id}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($permitPackUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($permitPackUserRequest));
            } else {
                $httpBody = $permitPackUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showMod
     *
     * Fetch a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function showMod($modId, string $contentType = self::contentTypes['showMod'][0])
    {
        list($response) = $this->showModWithHttpInfo($modId, $contentType);
        return $response;
    }

    /**
     * Operation showModWithHttpInfo
     *
     * Fetch a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function showModWithHttpInfo($modId, string $contentType = self::contentTypes['showMod'][0])
    {
        $request = $this->showModRequest($modId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Mod',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Mod',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Mod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation showModAsync
     *
     * Fetch a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showModAsync($modId, string $contentType = self::contentTypes['showMod'][0])
    {
        return $this->showModAsyncWithHttpInfo($modId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showModAsyncWithHttpInfo
     *
     * Fetch a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showModAsyncWithHttpInfo($modId, string $contentType = self::contentTypes['showMod'][0])
    {
        $returnType = '\Kleister\Model\Mod';
        $request = $this->showModRequest($modId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showMod'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function showModRequest($modId, string $contentType = self::contentTypes['showMod'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling showMod'
            );
        }


        $resourcePath = '/mods/{mod_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showVersion
     *
     * Fetch a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function showVersion($modId, $versionId, string $contentType = self::contentTypes['showVersion'][0])
    {
        list($response) = $this->showVersionWithHttpInfo($modId, $versionId, $contentType);
        return $response;
    }

    /**
     * Operation showVersionWithHttpInfo
     *
     * Fetch a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function showVersionWithHttpInfo($modId, $versionId, string $contentType = self::contentTypes['showVersion'][0])
    {
        $request = $this->showVersionRequest($modId, $versionId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Version',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Version',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Version',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation showVersionAsync
     *
     * Fetch a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showVersionAsync($modId, $versionId, string $contentType = self::contentTypes['showVersion'][0])
    {
        return $this->showVersionAsyncWithHttpInfo($modId, $versionId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showVersionAsyncWithHttpInfo
     *
     * Fetch a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showVersionAsyncWithHttpInfo($modId, $versionId, string $contentType = self::contentTypes['showVersion'][0])
    {
        $returnType = '\Kleister\Model\Version';
        $request = $this->showVersionRequest($modId, $versionId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showVersion'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function showVersionRequest($modId, $versionId, string $contentType = self::contentTypes['showVersion'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling showVersion'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling showVersion'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions/{version_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMod
     *
     * Update a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function updateMod($modId, $createModRequest, string $contentType = self::contentTypes['updateMod'][0])
    {
        list($response) = $this->updateModWithHttpInfo($modId, $createModRequest, $contentType);
        return $response;
    }

    /**
     * Operation updateModWithHttpInfo
     *
     * Update a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMod'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Mod|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateModWithHttpInfo($modId, $createModRequest, string $contentType = self::contentTypes['updateMod'][0])
    {
        $request = $this->updateModRequest($modId, $createModRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Mod',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Mod',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Mod',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateModAsync
     *
     * Update a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModAsync($modId, $createModRequest, string $contentType = self::contentTypes['updateMod'][0])
    {
        return $this->updateModAsyncWithHttpInfo($modId, $createModRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateModAsyncWithHttpInfo
     *
     * Update a specific mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModAsyncWithHttpInfo($modId, $createModRequest, string $contentType = self::contentTypes['updateMod'][0])
    {
        $returnType = '\Kleister\Model\Mod';
        $request = $this->updateModRequest($modId, $createModRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMod'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  \Kleister\Model\CreateModRequest $createModRequest The mod data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMod'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateModRequest($modId, $createModRequest, string $contentType = self::contentTypes['updateMod'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling updateMod'
            );
        }

        // verify the required parameter 'createModRequest' is set
        if ($createModRequest === null || (is_array($createModRequest) && count($createModRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createModRequest when calling updateMod'
            );
        }


        $resourcePath = '/mods/{mod_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createModRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createModRequest));
            } else {
                $httpBody = $createModRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVersion
     *
     * Update a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification
     */
    public function updateVersion($modId, $versionId, $createVersionRequest, string $contentType = self::contentTypes['updateVersion'][0])
    {
        list($response) = $this->updateVersionWithHttpInfo($modId, $versionId, $createVersionRequest, $contentType);
        return $response;
    }

    /**
     * Operation updateVersionWithHttpInfo
     *
     * Update a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVersion'] to see the possible values for this operation
     *
     * @throws \Kleister\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kleister\Model\Version|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification|\Kleister\Model\Notification, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVersionWithHttpInfo($modId, $versionId, $createVersionRequest, string $contentType = self::contentTypes['updateVersion'][0])
    {
        $request = $this->updateVersionRequest($modId, $versionId, $createVersionRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Version',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Kleister\Model\Notification',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kleister\Model\Version',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Version',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kleister\Model\Notification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateVersionAsync
     *
     * Update a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVersionAsync($modId, $versionId, $createVersionRequest, string $contentType = self::contentTypes['updateVersion'][0])
    {
        return $this->updateVersionAsyncWithHttpInfo($modId, $versionId, $createVersionRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVersionAsyncWithHttpInfo
     *
     * Update a specific version for a mod
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVersionAsyncWithHttpInfo($modId, $versionId, $createVersionRequest, string $contentType = self::contentTypes['updateVersion'][0])
    {
        $returnType = '\Kleister\Model\Version';
        $request = $this->updateVersionRequest($modId, $versionId, $createVersionRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVersion'
     *
     * @param  string $modId A mod identifier or slug (required)
     * @param  string $versionId A version identifier or slug (required)
     * @param  \Kleister\Model\CreateVersionRequest $createVersionRequest The version data to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateVersionRequest($modId, $versionId, $createVersionRequest, string $contentType = self::contentTypes['updateVersion'][0])
    {

        // verify the required parameter 'modId' is set
        if ($modId === null || (is_array($modId) && count($modId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modId when calling updateVersion'
            );
        }

        // verify the required parameter 'versionId' is set
        if ($versionId === null || (is_array($versionId) && count($versionId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $versionId when calling updateVersion'
            );
        }

        // verify the required parameter 'createVersionRequest' is set
        if ($createVersionRequest === null || (is_array($createVersionRequest) && count($createVersionRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createVersionRequest when calling updateVersion'
            );
        }


        $resourcePath = '/mods/{mod_id}/versions/{version_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($modId !== null) {
            $resourcePath = str_replace(
                '{' . 'mod_id' . '}',
                ObjectSerializer::toPathValue($modId),
                $resourcePath
            );
        }
        // path params
        if ($versionId !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($versionId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createVersionRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createVersionRequest));
            } else {
                $httpBody = $createVersionRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
